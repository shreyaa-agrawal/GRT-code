/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;

class RoomAvailabilityCalendarTest {
    
    private static final String ROOM_101 = "ROOM101";
    private static final String ROOM_102 = "ROOM102";
    private static final String ROOM_201 = "ROOM201";
    private static final String ROOM_202 = "ROOM202";
    private static final String ROOM_301 = "ROOM301";

    @Nested
    @DisplayName("Data Masking Tests")
    class DataMaskingTests {

        @ParameterizedTest
        @ValueSource(strings = {"GUEST123", "AB", "X", "VERYLONGGUEST456", "G1"})
        @DisplayName("Should mask guest ID correctly for various lengths")
        void shouldMaskGuestIdCorrectly(String guestId) {
            String masked = RoomAvailabilityCalendar.maskGuestId(guestId);
            
            if (guestId.length() <= 2) {
                assertEquals("*".repeat(guestId.length()), masked);
            } else {
                assertTrue(masked.startsWith(String.valueOf(guestId.charAt(0))));
                assertTrue(masked.endsWith(String.valueOf(guestId.charAt(guestId.length() - 1))));
                assertTrue(masked.contains("*"));
                assertEquals(guestId.length(), masked.length());
            }
        }

        @ParameterizedTest
        @CsvSource({
            "guest@example.com, ***@example.com",
            "user@domain.org, ***@domain.org", 
            "test@gmail.com, ***@gmail.com",
            "a@b.com, ***@b.com"
        })
        @DisplayName("Should mask email correctly")
        void shouldMaskEmailCorrectly(String email, String expected) {
            assertEquals(expected, RoomAvailabilityCalendar.maskEmail(email));
        }

        @Test
        @DisplayName("Should handle invalid email formats")
        void shouldHandleInvalidEmailFormats() {
            assertEquals("***", RoomAvailabilityCalendar.maskEmail("invalid"));
            assertEquals("***", RoomAvailabilityCalendar.maskEmail(""));
            assertEquals("***", RoomAvailabilityCalendar.maskEmail("@"));
            assertEquals("***", RoomAvailabilityCalendar.maskEmail("@domain.com"));
        }

        @Test
        @DisplayName("Should handle null inputs in masking")
        void shouldHandleNullInputsInMasking() {
            assertEquals("*****", RoomAvailabilityCalendar.maskGuestId(null));
            assertEquals("*****", RoomAvailabilityCalendar.maskGuestId(""));
            assertEquals("***", RoomAvailabilityCalendar.maskEmail(null));
            assertEquals("***", RoomAvailabilityCalendar.maskEmail(""));
        }
    }

    @Nested
    @DisplayName("DateRange Tests")
    class DateRangeTests {

        @Test
        @DisplayName("Should detect overlapping ranges")
        void shouldDetectOverlappingRanges() {
            RoomAvailabilityCalendar.DateRange range1 = 
                new RoomAvailabilityCalendar.DateRange(
                    LocalDate.of(2024, 1, 1), LocalDate.of(2024, 1, 5));
            RoomAvailabilityCalendar.DateRange range2 = 
                new RoomAvailabilityCalendar.DateRange(
                    LocalDate.of(2024, 1, 3), LocalDate.of(2024, 1, 7));

            assertTrue(range1.overlaps(range2));
            assertTrue(range2.overlaps(range1));
        }

        @Test
        @DisplayName("Should detect non-overlapping ranges")
        void shouldDetectNonOverlappingRanges() {
            RoomAvailabilityCalendar.DateRange range1 = 
                new RoomAvailabilityCalendar.DateRange(
                    LocalDate.of(2024, 1, 1), LocalDate.of(2024, 1, 3));
            RoomAvailabilityCalendar.DateRange range2 = 
                new RoomAvailabilityCalendar.DateRange(
                    LocalDate.of(2024, 1, 5), LocalDate.of(2024, 1, 7));

            assertFalse(range1.overlaps(range2));
            assertFalse(range2.overlaps(range1));
        }

        @Test 
        @DisplayName("Should handle touching ranges")
        void shouldHandleTouchingRanges() {
            RoomAvailabilityCalendar.DateRange range1 = 
                new RoomAvailabilityCalendar.DateRange(
                    LocalDate.of(2024, 1, 1), LocalDate.of(2024, 1, 3));
            RoomAvailabilityCalendar.DateRange range2 = 
                new RoomAvailabilityCalendar.DateRange(
                    LocalDate.of(2024, 1, 3), LocalDate.of(2024, 1, 5));

            assertTrue(range1.overlaps(range2));
            assertTrue(range2.overlaps(range1));
        }
    }

    @Nested
    @DisplayName("Availability Calculation Tests")
    class AvailabilityCalculationTests {

        @Test
        @DisplayName("Should calculate availability with no conflicts")
        void shouldCalculateAvailabilityWithNoConflicts() {
            List<RoomAvailabilityCalendar.Booking> bookings = List.of(
                new RoomAvailabilityCalendar.Booking("G***1", ROOM_101, 
                    LocalDate.of(2024, 1, 1), LocalDate.of(2024, 1, 3))
            );
            
            List<RoomAvailabilityCalendar.Maintenance> maintenance = List.of();
            List<RoomAvailabilityCalendar.LinkedRoomType> linkedRooms = List.of();

            Map<String, List<RoomAvailabilityCalendar.DateRange>> availability = 
                RoomAvailabilityCalendar.calculateAvailability(bookings, maintenance, linkedRooms);

            assertTrue(availability.containsKey(ROOM_101));
            assertNotNull(availability.get(ROOM_101));
            assertFalse(availability.isEmpty());
        }

        @Test
        @DisplayName("Should detect overlapping bookings")
        void shouldDetectOverlappingBookings() {
            List<RoomAvailabilityCalendar.Booking> bookings = List.of(
                new RoomAvailabilityCalendar.Booking("G***1", ROOM_101, 
                    LocalDate.of(2024, 1, 1), LocalDate.of(2024, 1, 5)),
                new RoomAvailabilityCalendar.Booking("G***2", ROOM_101, 
                    LocalDate.of(2024, 1, 3), LocalDate.of(2024, 1, 7))
            );
            
            List<RoomAvailabilityCalendar.Maintenance> maintenance = List.of();
            List<RoomAvailabilityCalendar.LinkedRoomType> linkedRooms = List.of();

            assertThrows(IllegalStateException.class, () -> {
                RoomAvailabilityCalendar.calculateAvailability(bookings, maintenance, linkedRooms);
            });
        }

        @Test
        @DisplayName("Should handle maintenance periods correctly")
        void shouldHandleMaintenancePeriodsCorrectly() {
            List<RoomAvailabilityCalendar.Booking> bookings = List.of(
                new RoomAvailabilityCalendar.Booking("G***1", ROOM_101,
                    LocalDate.of(2024, 1, 1), LocalDate.of(2024, 1, 3))
            );
            List<RoomAvailabilityCalendar.Maintenance> maintenance = List.of(
                new RoomAvailabilityCalendar.Maintenance(ROOM_101,
                    LocalDate.of(2024, 1, 10), LocalDate.of(2024, 1, 12))
            );
            List<RoomAvailabilityCalendar.LinkedRoomType> linkedRooms = List.of();

            Map<String, List<RoomAvailabilityCalendar.DateRange>> availability = 
                RoomAvailabilityCalendar.calculateAvailability(bookings, maintenance, linkedRooms);

            assertTrue(availability.containsKey(ROOM_101));
            List<RoomAvailabilityCalendar.DateRange> roomAvail = availability.get(ROOM_101);
            assertNotNull(roomAvail);
        }

        @Test
        @DisplayName("Should calculate linked room availability as intersection")
        void shouldCalculateLinkedRoomAvailability() {
            List<RoomAvailabilityCalendar.Booking> bookings = List.of(
                new RoomAvailabilityCalendar.Booking("G***1", ROOM_101, 
                    LocalDate.of(2024, 1, 1), LocalDate.of(2024, 1, 3))
            );
            
            List<RoomAvailabilityCalendar.Maintenance> maintenance = List.of();
            List<RoomAvailabilityCalendar.LinkedRoomType> linkedRooms = List.of(
                new RoomAvailabilityCalendar.LinkedRoomType("SUITE001", 
                    List.of(ROOM_101, ROOM_102))
            );

            Map<String, List<RoomAvailabilityCalendar.DateRange>> availability = 
                RoomAvailabilityCalendar.calculateAvailability(bookings, maintenance, linkedRooms);

            assertTrue(availability.containsKey("SUITE001"));
            assertTrue(availability.containsKey(ROOM_101));
            assertTrue(availability.containsKey(ROOM_102));
        }

        @Test
        @DisplayName("Should handle empty inputs")
        void shouldHandleEmptyInputs() {
            Map<String, List<RoomAvailabilityCalendar.DateRange>> availability = 
                RoomAvailabilityCalendar.calculateAvailability(
                    List.of(), List.of(), List.of());

            assertTrue(availability.isEmpty());
        }
    }

    @Nested
    @DisplayName("JSON Output Tests")
    class JsonOutputTests {

        @Test
        @DisplayName("Should generate valid JSON output")
        void shouldGenerateValidJsonOutput() {
            Map<String, List<RoomAvailabilityCalendar.DateRange>> availability = Map.of(
                ROOM_101, List.of(
                    new RoomAvailabilityCalendar.DateRange(
                        LocalDate.of(2024, 1, 1), LocalDate.of(2024, 1, 10))
                )
            );

            String json = RoomAvailabilityCalendar.availabilityToJson(availability);
            
            assertNotNull(json);
            assertTrue(json.contains(ROOM_101));
            assertTrue(json.contains("2024-01-01"));
            assertTrue(json.contains("2024-01-10"));
            assertTrue(json.contains("\"from\":"));
            assertTrue(json.contains("\"to\":"));
        }

        @Test
        @DisplayName("Should handle empty availability")
        void shouldHandleEmptyAvailability() {
            String json = RoomAvailabilityCalendar.availabilityToJson(Map.of());
            assertEquals("{}", json);
        }
    }

    @Nested
    @DisplayName("Record Validation Tests")
    class RecordValidationTests {

        @Test
        @DisplayName("Should create valid Booking record")
        void shouldCreateValidBookingRecord() {
            RoomAvailabilityCalendar.Booking booking = 
                new RoomAvailabilityCalendar.Booking(
                    "G***1", ROOM_101, 
                    LocalDate.of(2024, 1, 1), LocalDate.of(2024, 1, 3)
                );
            
            assertEquals("G***1", booking.maskedGuestId());
            assertEquals(ROOM_101, booking.roomId());
            assertEquals(LocalDate.of(2024, 1, 1), booking.from());
            assertEquals(LocalDate.of(2024, 1, 3), booking.to());
        }

        @Test
        @DisplayName("Should create valid DateRange record")
        void shouldCreateValidDateRangeRecord() {
            RoomAvailabilityCalendar.DateRange dateRange = 
                new RoomAvailabilityCalendar.DateRange(
                    LocalDate.of(2024, 1, 1), LocalDate.of(2024, 1, 3)
                );
            
            assertEquals(LocalDate.of(2024, 1, 1), dateRange.start());
            assertEquals(LocalDate.of(2024, 1, 3), dateRange.end());
        }
    }
}
